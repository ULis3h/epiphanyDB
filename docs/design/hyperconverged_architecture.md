# EpiphanyDB 超融合数据库架构设计

## 1. 架构概述

EpiphanyDB 2.0 将重构为超融合数据库系统，对标 YMatrix，实现"一库多用"的设计理念。新架构采用微内核 + MPP 分布式架构，同时支持 OLTP、OLAP 和时序数据处理场景。

## 2. 核心架构设计

### 2.1 微内核架构

```
┌─────────────────────────────────────────────────────────────┐
│                    EpiphanyDB 超融合架构                      │
├─────────────────────────────────────────────────────────────┤
│                      统一 SQL 接口层                         │
├─────────────────────────────────────────────────────────────┤
│  查询优化器 (CBO)  │  事务管理  │  元数据管理  │  安全管理    │
├─────────────────────────────────────────────────────────────┤
│                      微内核调度层                            │
├─────────────────────────────────────────────────────────────┤
│  OLTP 内核     │   OLAP 内核    │   时序内核   │   向量内核   │
│ (HEAP+火山)    │ (列存+向量化)   │ (MARS+向量化) │ (向量+GPU)   │
├─────────────────────────────────────────────────────────────┤
│                    统一存储引擎层                            │
├─────────────────────────────────────────────────────────────┤
│     缓冲池管理     │    页面管理    │    索引管理             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 MPP 分布式架构

```
┌─────────────────────────────────────────────────────────────┐
│                      Master 节点                            │
│  ┌─────────────────┐  ┌─────────────────┐                  │
│  │   元数据管理     │  │   查询协调器     │                  │
│  └─────────────────┘  └─────────────────┘                  │
└─────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼──────┐    ┌─────────▼──────┐    ┌─────────▼──────┐
│  Segment 1   │    │   Segment 2    │    │   Segment N    │
│ ┌──────────┐ │    │ ┌────────────┐ │    │ ┌────────────┐ │
│ │OLTP 内核 │ │    │ │ OLAP 内核  │ │    │ │ 时序内核   │ │
│ └──────────┘ │    │ └────────────┘ │    │ └────────────┘ │
│ ┌──────────┐ │    │ ┌────────────┐ │    │ ┌────────────┐ │
│ │本地存储  │ │    │ │ 本地存储   │ │    │ │ 本地存储   │ │
│ └──────────┘ │    │ └────────────┘ │    │ └────────────┘ │
└──────────────┘    └────────────────┘    └────────────────┘
```

## 3. 核心组件设计

### 3.1 微内核系统

#### OLTP 内核
- **存储引擎**: HEAP 行存储
- **执行引擎**: 火山模型执行器
- **事务支持**: MVCC + 2PL
- **适用场景**: 高并发事务处理

#### OLAP 内核  
- **存储引擎**: 列式存储 + 压缩
- **执行引擎**: 向量化执行器
- **优化器**: 基于代价的优化器 (CBO)
- **适用场景**: 复杂分析查询

#### 时序内核
- **存储引擎**: MARS2 时序存储
- **执行引擎**: 向量化 + 时序优化
- **索引**: 时间索引 + 标签索引
- **适用场景**: IoT、监控数据

#### 向量内核
- **存储引擎**: 向量存储 + 近似索引
- **执行引擎**: GPU 加速计算
- **算法**: HNSW、IVF 等向量检索
- **适用场景**: AI/ML、相似性搜索

### 3.2 统一存储层

#### 存储引擎抽象
```cpp
class StorageEngine {
public:
    virtual Status Insert(const Record& record) = 0;
    virtual Status Update(const RecordId& rid, const Record& record) = 0;
    virtual Status Delete(const RecordId& rid) = 0;
    virtual Iterator* Scan(const ScanSpec& spec) = 0;
    virtual Status CreateIndex(const IndexSpec& spec) = 0;
};
```

#### 多存储格式支持
- **行存储**: 适合 OLTP 场景
- **列存储**: 适合 OLAP 场景  
- **时序存储**: 适合时间序列数据
- **向量存储**: 适合 AI/ML 场景

### 3.3 查询处理器

#### 统一 SQL 解析器
- 支持标准 SQL
- 扩展时序 SQL 语法
- 向量查询语法支持

#### 智能查询优化器
- 基于代价的优化 (CBO)
- 多内核路由决策
- 执行计划缓存

#### 多模式执行引擎
- 火山模型执行器 (OLTP)
- 向量化执行器 (OLAP/时序)
- GPU 加速执行器 (向量)

## 4. 关键技术特性

### 4.1 行列混存
- 智能存储格式选择
- 动态格式转换
- 压缩算法优化

### 4.2 向量化执行
- SIMD 指令优化
- 批量数据处理
- 内存访问优化

### 4.3 分布式事务
- 两阶段提交 (2PC)
- 分布式锁管理
- 故障恢复机制

### 4.4 高可用设计
- 主备自动切换
- 数据多副本
- 故障检测与恢复

## 5. 性能目标

### 5.1 OLTP 性能
- TPS: > 100,000 事务/秒
- 延迟: < 1ms (P99)
- 并发: > 10,000 连接

### 5.2 OLAP 性能
- 扫描: > 10GB/秒/节点
- 压缩比: 5:1 - 10:1
- 查询延迟: 秒级到分钟级

### 5.3 时序性能
- 写入: > 1,000,000 点/秒/节点
- 压缩比: 10:1 - 20:1
- 查询延迟: 毫秒级

## 6. 兼容性设计

### 6.1 协议兼容
- PostgreSQL 协议兼容
- MySQL 协议支持 (可选)
- 原生 gRPC API

### 6.2 生态兼容
- JDBC/ODBC 驱动
- 主流 BI 工具支持
- 云原生部署支持

## 7. 实施路线图

### Phase 1: 核心架构 (3个月)
- 微内核框架搭建
- 基础存储引擎重构
- 统一 SQL 解析器

### Phase 2: OLTP/OLAP 内核 (4个月)
- OLTP 内核实现
- OLAP 内核实现
- 查询优化器重构

### Phase 3: 时序/向量内核 (3个月)
- 时序内核实现
- 向量内核实现
- 性能优化调优

### Phase 4: 分布式扩展 (2个月)
- MPP 架构实现
- 分布式事务
- 高可用机制

## 8. 技术风险与应对

### 8.1 性能风险
- **风险**: 多内核切换开销
- **应对**: 智能路由算法，减少切换频率

### 8.2 兼容性风险
- **风险**: PostgreSQL 兼容性问题
- **应对**: 渐进式迁移，保持核心兼容性

### 8.3 复杂性风险
- **风险**: 系统复杂度过高
- **应对**: 模块化设计，清晰的接口定义